// Code generated by MockGen. DO NOT EDIT.
// Source: flow/consumer_worker.go

// Package mock is a generated GoMock package.
package mock

import (
	reflect "reflect"

	sarama "github.com/Shopify/sarama"
	sarama_cluster "github.com/bsm/sarama-cluster"
	gomock "github.com/golang/mock/gomock"
)

// MockConsumerWorker is a mock of ConsumerWorker interface
type MockConsumerWorker struct {
	ctrl     *gomock.Controller
	recorder *MockConsumerWorkerMockRecorder
}

// MockConsumerWorkerMockRecorder is the mock recorder for MockConsumerWorker
type MockConsumerWorkerMockRecorder struct {
	mock *MockConsumerWorker
}

// NewMockConsumerWorker creates a new mock instance
func NewMockConsumerWorker(ctrl *gomock.Controller) *MockConsumerWorker {
	mock := &MockConsumerWorker{ctrl: ctrl}
	mock.recorder = &MockConsumerWorkerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockConsumerWorker) EXPECT() *MockConsumerWorkerMockRecorder {
	return m.recorder
}

// Start mocks base method
func (m *MockConsumerWorker) Start() {
	m.ctrl.Call(m, "Start")
}

// Start indicates an expected call of Start
func (mr *MockConsumerWorkerMockRecorder) Start() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockConsumerWorker)(nil).Start))
}

// Stop mocks base method
func (m *MockConsumerWorker) Stop() {
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop
func (mr *MockConsumerWorkerMockRecorder) Stop() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockConsumerWorker)(nil).Stop))
}

// Start mocks base method
func (m *MockConsumerWorker) Halt() {
	m.ctrl.Call(m, "Start")
}

// Start indicates an expected call of Start
func (mr *MockConsumerWorkerMockRecorder) Halt() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Halt", reflect.TypeOf((*MockConsumerWorker)(nil).Halt))
}

// IsStart mocks base method
func (m *MockConsumerWorker) IsStart() bool {
	ret := m.ctrl.Call(m, "IsStart")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsStart indicates an expected call of IsStart
func (mr *MockConsumerWorkerMockRecorder) IsStart() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsStart", reflect.TypeOf((*MockConsumerWorker)(nil).IsStart))
}

// IsHalt mocks base method
func (m *MockConsumerWorker) IsHalt() bool {
	ret := m.ctrl.Call(m, "IsHalt")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsStart indicates an expected call of IsStart
func (mr *MockConsumerWorkerMockRecorder) IsHalt() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsHalt", reflect.TypeOf((*MockConsumerWorker)(nil).IsHalt))
}

// OnError mocks base method
func (m *MockConsumerWorker) OnError(f func(error)) {
	m.ctrl.Call(m, "OnError", f)
}

// OnError indicates an expected call of OnError
func (mr *MockConsumerWorkerMockRecorder) OnError(f interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnError", reflect.TypeOf((*MockConsumerWorker)(nil).OnError), f)
}

// OnSuccess mocks base method
func (m *MockConsumerWorker) OnSuccess(f func(*sarama.ConsumerMessage)) {
	m.ctrl.Call(m, "OnSuccess", f)
}

// OnSuccess indicates an expected call of OnSuccess
func (mr *MockConsumerWorkerMockRecorder) OnSuccess(f interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnSuccess", reflect.TypeOf((*MockConsumerWorker)(nil).OnSuccess), f)
}

// OnNotification mocks base method
func (m *MockConsumerWorker) OnNotification(f func(*sarama_cluster.Notification)) {
	m.ctrl.Call(m, "OnNotification", f)
}

// OnNotification indicates an expected call of OnNotification
func (mr *MockConsumerWorkerMockRecorder) OnNotification(f interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnNotification", reflect.TypeOf((*MockConsumerWorker)(nil).OnNotification), f)
}

// OnHalt mocks base method
func (m *MockConsumerWorker) OnHalt(f func()) {
	m.ctrl.Call(m, "OnHalt", f)
}
